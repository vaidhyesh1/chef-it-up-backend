# -*- coding: utf-8 -*-
"""API.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1XDf-wv8l29QSEpsWCtEkPfp66FDW6sY4

"""## Imports"""

import pandas as pd
import numpy as np
from numpy import dot
from numpy.linalg import norm
import pickle
import random
import json
from flask import Flask, jsonify, request

app = Flask(__name__)
"""## Load Global Data"""

directory = 'Cleaned-60M-30N'

matrixUserItem = np.loadtxt('{}/UserItemMatrix.csv'.format(directory), delimiter=',')
matrixUserFollows = np.loadtxt('{}/UserFollowsMatrix.csv'.format(directory), delimiter=',')
matrixUserTag = np.loadtxt('{}/UserTagMatrix.csv'.format(directory), delimiter=',')
matrixItemTag = np.loadtxt('{}/ItemTagMatrix.csv'.format(directory), delimiter=',')
itemNamesDF = pd.read_csv("{}/Recipes.csv".format(directory), delimiter=',')

with open('{}/filteredItems.txt'.format(directory), 'rb') as f:
  filteredItems = pickle.load(f)
with open('{}/filteredTags.txt'.format(directory), 'rb') as f:
  filteredTags = pickle.load(f)

matrixUserItem = (matrixUserItem > 0).astype(float)
matrixUserTag = (matrixUserTag > 0).astype(float)

"""## Precompute"""

def getSimilarityMatrix(matrix, sim_type="cosine"):
  similarityMatrix = np.zeros((len(matrix), len(matrix)))

  if sim_type == "cosine":
    for i in range(len(matrix)):
      for j in range(i+1, len(matrix)):
        similarityScore = dot(matrix[i], matrix[j])/(norm(matrix[i]) * norm(matrix[j]))
        similarityMatrix[i][j] = similarityScore
        similarityMatrix[j][i] = similarityScore

  else:
    for i in range(len(matrix)):
      for j in range(i+1, len(matrix)):
        im1 = np.asarray(matrix[i]).astype(bool)
        im2 = np.asarray(matrix[j]).astype(bool)

        intersection = np.logical_and(im1, im2)
        union = np.logical_or(im1, im2)
        similarityScore =  intersection.sum() / float(union.sum())

        similarityMatrix[i][j] = similarityScore
        similarityMatrix[j][i] = similarityScore
  
  return similarityMatrix

def getSimilarElements(matrix, k, sim_type="cosine"):
  similarityMatrix = getSimilarityMatrix(matrix, sim_type)
  similarElements = []
  
  for i in range(len(similarityMatrix)):
    topSimilarElements = dict()
    userSimilarity = similarityMatrix[i]
    keys = (-userSimilarity).argsort()[:k]
    
    for key in keys:
      topSimilarElements[key] = userSimilarity[key]
    
    similarElements.append(topSimilarElements)
  
  return similarElements

def getSimilarUsersbyFollows(matrix, matrixUserFollows):
  similarityMatrix = getSimilarityMatrix(matrix)
  similarElements = []

  for i in range(len(similarityMatrix)):
    topSimilarElements = dict()
    followIndexes = np.where(matrixUserFollows[i] > 0)[0]

    for followIndex in followIndexes:
      topSimilarElements[followIndex] = similarityMatrix[i][followIndex]
    
    similarElements.append(topSimilarElements)

  return similarElements

def precompute():
  similarUsersbyRating = getSimilarElements(matrixUserItem, 10)
  similarUsersbyFollows = getSimilarUsersbyFollows(matrixUserItem, matrixUserFollows)
  similarItemsCosinebyTag = getSimilarElements(matrixItemTag, 25, "cosine")
  similarItemsJaccardbyTag = getSimilarElements(matrixItemTag, 25, "jaccard")

  return similarUsersbyRating, similarUsersbyFollows, similarItemsCosinebyTag, similarItemsJaccardbyTag

similarUsersbyRating, similarUsersbyFollows, similarItemsCosinebyTag, similarItemsJaccardbyTag = precompute()

"""## Explainable"""

def getExplainableforUserbyRating(user, itemIDs, k):
  similarUserIDs = list(similarUsersbyRating[user].keys())
  explainableTags = dict()

  for itemID in itemIDs:
    contributionMatrix = np.zeros((len(similarUserIDs), matrixUserTag.shape[1]))
    userTags = matrixUserTag[user]

    for i in range(len(similarUserIDs)):
      similarUserID = similarUserIDs[i]
      similarUserTags = matrixUserTag[similarUserID]
      similarUserScalar = norm(similarUserTags)

      for j in range(len(userTags)):
        contributionMatrix[i][j] = (userTags[j] * similarUserTags[j])/similarUserScalar
      
      contributionMatrix[i] *= matrixUserItem[similarUserID][itemID]
    
    contributionSum = contributionMatrix.sum(axis=0)

    # Most Users ask for "low-fat". Taking ranks 2 - k+1 for diversity.
    contributionTags = (-contributionSum).argsort()[1:k+1]
    contributingTags = list()

    for contributionTag in contributionTags:
      contributingTags.append(filteredTags[contributionTag])
    
    explainableTags[itemID] = contributingTags
  
  return explainableTags

def getExplainableforUserbyFollows(user, itemIDs, k):
  followUserIDs = list(similarUsersbyFollows[user].keys())
  explainableUsers = dict()

  for itemID in itemIDs:
    contributions = np.zeros(len(matrixUserItem))

    for i in range(len(followUserIDs)):
      followUserID = followUserIDs[i]
      contributions[followUserID] = similarUsersbyFollows[user][followUserID] * matrixUserItem[followUserID][itemID]

    contributingUsers = list((-contributions).argsort())
    filteredContributingUsers = contributingUsers[0:k]

    for i in range(len(filteredContributingUsers)):
      filteredContributingUsers[i] = int(filteredContributingUsers[i])

    explainableUsers[itemID] = filteredContributingUsers
  
  return explainableUsers

"""#### Explainable Testing"""

getExplainableforUserbyRating(0, [2269, 633, 192], 2)

getExplainableforUserbyFollows(0, [1680, 179], 1)

"""## User User CF"""

def getUserRecommendation(user, k, similarUsers):
  ratings = matrixUserItem[user]
  similarUserKeys = list(similarUsers[user].keys())
  filteredRatings = np.where(ratings == 0)[0]

  unknownSimilarity = dict()
  for filteredRating in filteredRatings:
    numerator = 0
    denominator = 0

    for key in similarUserKeys:
      numerator += similarUsers[user][key] * matrixUserItem[key][filteredRating]
      denominator += similarUsers[user][key]
    
    if denominator == 0:
      continue
      
    unknownSimilarity[filteredRating] = numerator / denominator
  
  sortedUnknownSimilarity = dict(sorted(unknownSimilarity.items(), key=lambda item: item[1], reverse=True))
  userSimilarityRecommendation = list(sortedUnknownSimilarity.keys())[0:k]

  return userSimilarityRecommendation

"""#### User-User Testing"""

# Testing by ratings similarity
getUserRecommendation(0, 3, similarUsersbyRating)

# Testing by follows similarity
getUserRecommendation(0, 5, similarUsersbyFollows)

"""## User Item Recommendation"""

def get_user_item_recommendation(user_id, item_id, k, similarUsers, similarItems):
  potential_items = dict()
  candidateItems = similarItems[item_id]
  for j, j_sim in candidateItems.items():
    num = 0
    den = 0
    for v, v_sim in similarUsers[user_id].items():
      num += v_sim * matrixUserItem[v][j]
      den += v_sim
    potential_items[j] = num/den * j_sim 

  potential_items = {k: v for k, v in sorted(potential_items.items(), key=lambda item: item[1], reverse=True)[:k]}
  return list(potential_items.keys())

"""#### User-Item Testing"""

# Testing by ratings similarity
get_user_item_recommendation(0, 1680, 3, similarUsersbyRating, similarItemsCosinebyTag)

# Testing by follows similarity
get_user_item_recommendation(0, 1680, 5, similarUsersbyFollows, similarItemsJaccardbyTag)

"""## Recommendation API"""

def recommendationsforUser(userId):
  ratingsRecommendation = getUserRecommendation(userId, 3, similarUsersbyRating)
  followsRecommendation = getUserRecommendation(userId, 5, similarUsersbyFollows)

  ratingsExplainable = getExplainableforUserbyRating(userId, ratingsRecommendation, 2)
  followsExplainable = getExplainableforUserbyFollows(userId, followsRecommendation, 1)

  recommendations = []
  for i in ratingsRecommendation:
    recipeName = itemNamesDF[itemNamesDF['recipe_id'] == i]['name'].item()
    recommendation = dict()
    recommendation['id'] = int(i)
    recommendation['type'] = 'Rating'
    recommendation['name'] = recipeName
    recommendation['tags'] = ratingsExplainable[i]
    recommendations.append(recommendation)
  
  for i in followsRecommendation:
    if len(recommendations) >= 5:
      break
    
    if i in recommendations:
      continue
    
    recipeName = itemNamesDF[itemNamesDF['recipe_id'] == i]['name'].item()
    recommendation = dict()
    recommendation['id'] = int(i)
    recommendation['type'] = 'Follows'
    recommendation['name'] = recipeName
    recommendation['tags'] = followsExplainable[i]
    recommendations.append(recommendation)

  return recommendations

def recommendationsforUserItem(userId, itemId):
  ratingsRecommendation = get_user_item_recommendation(userId, itemId, 3, similarUsersbyRating, similarItemsCosinebyTag)
  followsRecommendation = get_user_item_recommendation(userId, itemId, 5, similarUsersbyFollows, similarItemsJaccardbyTag)

  ratingsExplainable = getExplainableforUserbyRating(userId, ratingsRecommendation, 2)
  followsExplainable = getExplainableforUserbyFollows(userId, followsRecommendation, 1)

  recommendations = []
  for i in ratingsRecommendation:
    recipeName = itemNamesDF[itemNamesDF['recipe_id'] == i]['name'].item()
    recommendation = dict()
    recommendation['id'] = int(i)
    recommendation['type'] = 'Rating'
    recommendation['name'] = recipeName
    recommendation['tags'] = ratingsExplainable[i]
    recommendations.append(recommendation)
  
  for i in followsRecommendation:
    if len(recommendations) >= 5:
      break
    
    if i in recommendations:
      continue
    
    recipeName = itemNamesDF[itemNamesDF['recipe_id'] == i]['name'].item()
    recommendation = dict()
    recommendation['id'] = int(i)
    recommendation['type'] = 'Follows'
    recommendation['name'] = recipeName
    recommendation['tags'] = followsExplainable[i]
    recommendations.append(recommendation)

  return recommendations

"""## Users API"""

def get_unique_users():
  return list(range(0, len(matrixUserItem)))

"""## Recipe API"""

def getRecipe(itemId):
  recipe = dict()
  recipeDF = itemNamesDF[itemNamesDF['recipe_id'] == itemId]

  recipe['id'] = itemId
  recipe['name'] = recipeDF['name'].item()
  recipe['tags'] = recipeDF['tags'].item()
  recipe['description'] = str(recipeDF['description'].item())
  recipe['ingredients'] = recipeDF['ingredients'].item()
  recipe['minutes'] = recipeDF['minutes'].item()
  recipe['steps'] = recipeDF['steps'].item()
  
  return recipe

def getAllRecipes():
  recipes = []

  for itemId in range(len(filteredItems)):
    recipe = dict()
    recipeDF = itemNamesDF[itemNamesDF['recipe_id'] == itemId]

    recipe['id'] = itemId
    recipe['name'] = recipeDF['name'].item()
    
    recipes.append(recipe)
  
  return recipes

uniqueUsers = get_unique_users()
allRecipes = getAllRecipes()

@app.route('/users', methods=['GET'])
def userList():
  return jsonify(uniqueUsers)

@app.route('/recipes', methods=['GET'])
def recipes():
  return jsonify(allRecipes)

@app.route('/recipe', methods=['GET'])
def recipesRec():
  args = request.args
  recipeId = int(args.get('recipeId'))
  if recipeId in uniqueUsers:
    return jsonify(getRecipe(recipeId))
  else:
    return jsonify({"error": "User Not found"})

@app.route('/recommendation', methods=['GET'])
def recommendation():
  args = request.args
  userId = int(args.get('userId'))
  if userId in uniqueUsers:
    return jsonify(recommendationsforUser(userId))
  else:
    return jsonify({"error": "User Not found"})
  
@app.route('/recommendationBasedOnClick', methods=['GET'])
def recommendationBasedOnClick():
  args = request.args
  userId = int(args.get('userId'))
  recipeId = int(args.get('recipeId'))
  if userId in uniqueUsers:
    return jsonify(recommendationsforUserItem(userId, recipeId))
  else:
    return jsonify({"error": "User Not found"})


if __name__ == '__main__':
	app.run(debug=True)