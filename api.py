# -*- coding: utf-8 -*-
"""API.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1XDf-wv8l29QSEpsWCtEkPfp66FDW6sY4

## Drive
"""

# Commented out IPython magic to ensure Python compatibility.

import pandas as pd
import numpy as np
from numpy import dot
from numpy.linalg import norm
import pickle
import random
import json
import math
import ast
from flask import Flask, jsonify, request
from flask_cors import CORS, cross_origin


app = Flask(__name__)
cors = CORS(app)
app.config['CORS_HEADERS'] = 'Content-Type'
"""## Load Global Data"""

directory = '/home/vaidhyesh/mysite/Cleaned-60M-30N'

matrixUserItem = np.loadtxt('{}/UserItemMatrix.csv'.format(directory), delimiter=',')
matrixUserFollows = np.loadtxt('{}/UserFollowsMatrix.csv'.format(directory), delimiter=',')
matrixUserTag = np.loadtxt('{}/UserTagMatrix.csv'.format(directory), delimiter=',')
matrixItemTag = np.loadtxt('{}/ItemTagMatrix.csv'.format(directory), delimiter=',')
itemNamesDF = pd.read_csv('{}/Recipes.csv'.format(directory))

with open('{}/filteredItems.txt'.format(directory), 'rb') as f:
  filteredItems = pickle.load(f)
with open('{}/filteredTags.txt'.format(directory), 'rb') as f:
  filteredTags = pickle.load(f)

badTags = ['preparation', 'time-to-make', 'course', 'main-ingredient', 'equipment', 'occasion',
           'main-dish', 'technique', 'cuisine', 'low-in-something', 'high-in-something', 'copycat',
           'small-appliance', 'taste-mood', 'brown-bag', 'number-of-servings']
for badTag in badTags:
  index = filteredTags.index(badTag)
  matrixUserTag[:,index] *= 0
  matrixItemTag[:,index] *= 0

itemNamesDF.description = itemNamesDF.description.fillna('')

matrixUserItem = (matrixUserItem > 0).astype(float)
matrixUserTag = (matrixUserTag > 0).astype(float)

"""## Precompute"""

def getSimilarityMatrix(matrix, sim_type="cosine"):
  similarityMatrix = np.zeros((len(matrix), len(matrix)))

  if sim_type == "cosine":
    for i in range(len(matrix)):
      for j in range(i+1, len(matrix)):
        similarityScore = dot(matrix[i], matrix[j])/(norm(matrix[i]) * norm(matrix[j]))
        similarityMatrix[i][j] = similarityScore
        similarityMatrix[j][i] = similarityScore

  else:
    for i in range(len(matrix)):
      for j in range(i+1, len(matrix)):
        im1 = np.asarray(matrix[i]).astype(bool)
        im2 = np.asarray(matrix[j]).astype(bool)

        intersection = np.logical_and(im1, im2)
        union = np.logical_or(im1, im2)
        similarityScore =  intersection.sum() / float(union.sum())

        similarityMatrix[i][j] = similarityScore
        similarityMatrix[j][i] = similarityScore

  return similarityMatrix

def getSimilarElements(matrix, k, sim_type="cosine"):
  similarityMatrix = getSimilarityMatrix(matrix, sim_type)
  similarElements = list()

  for i in range(len(similarityMatrix)):
    topSimilarElements = dict()
    userSimilarity = similarityMatrix[i]
    keys = (-userSimilarity).argsort()[:k]

    for key in keys:
      topSimilarElements[key] = userSimilarity[key]

    similarElements.append(topSimilarElements)

  return similarElements

def getSimilarUsersbyFollows(matrix, matrixUserFollows):
  similarityMatrix = getSimilarityMatrix(matrix)
  similarElements = list()

  for i in range(len(similarityMatrix)):
    topSimilarElements = dict()
    followIndexes = np.where(matrixUserFollows[i] > 0)[0]

    for followIndex in followIndexes:
      topSimilarElements[followIndex] = similarityMatrix[i][followIndex]

    similarElements.append(topSimilarElements)

  return similarElements

def precompute():
  userRatingSimilarityMatrix = getSimilarityMatrix(matrixUserItem)
  similarUsersbyRating = getSimilarElements(matrixUserItem, 10)
  similarUsersbyFollows = getSimilarUsersbyFollows(matrixUserItem, matrixUserFollows)
  similarItemsbyTag = getSimilarElements(matrixItemTag, 35, "cosine")

  return userRatingSimilarityMatrix, similarUsersbyRating, similarUsersbyFollows, similarItemsbyTag

userRatingSimilarityMatrix, similarUsersbyRating, similarUsersbyFollows, similarItemsbyTag = precompute()

def updateUserFollowsSimilarity(userId):
  topSimilarElements = dict()
  followIndexes = np.where(matrixUserFollows[userId] > 0)[0]

  for followIndex in followIndexes:
    topSimilarElements[followIndex] = userRatingSimilarityMatrix[userId][followIndex]

  similarUsersbyFollows[userId] = topSimilarElements

"""## Explainable"""

def getExplainableforUserbyRating(user, itemIDs, k):
  l = math.ceil(k/2)
  similarUserIDs = list(similarUsersbyRating[user].keys())
  explainableTags = dict()

  for itemID in itemIDs:
    contributionMatrix = np.zeros((len(similarUserIDs), matrixUserTag.shape[1]))
    userTags = matrixUserTag[user]
    itemTags = matrixItemTag[itemID]
    itemTags = (itemTags > 0).astype(float)

    for i in range(len(similarUserIDs)):
      similarUserID = similarUserIDs[i]
      similarUserTags = matrixUserTag[similarUserID]
      similarUserScalar = norm(similarUserTags)

      for j in range(len(userTags)):
        contributionMatrix[i][j] = (userTags[j] * similarUserTags[j])/similarUserScalar

      contributionMatrix[i] *= matrixUserItem[similarUserID][itemID]

    contributionSum = contributionMatrix.sum(axis=0)

    # Most Users ask for "low-fat". Taking ranks 2 - l+1 for diversity.
    contributionUserTags = (-contributionSum).argsort()
    contributionItemTags = (-(contributionSum * itemTags)).argsort()
    contributionTags = contributionUserTags[1:l+1]

    for contributionItemTag in contributionItemTags:
      if len(contributionTags) >= k:
        break

      if contributionItemTag in contributionTags:
        continue
      else:
        contributionTags = np.append(contributionTags, contributionItemTag)

    contributingTags = list()
    for contributionTag in contributionTags:
      contributingTags.append(filteredTags[contributionTag])

    explainableTags[itemID] = contributingTags

  return explainableTags

def getExplainableforUserbyFollows(user, itemIDs, k):
  followUserIDs = list(similarUsersbyFollows[user].keys())
  explainableUsers = dict()

  for itemID in itemIDs:
    contributions = np.zeros(len(matrixUserItem))

    for i in range(len(followUserIDs)):
      followUserID = followUserIDs[i]
      contributions[followUserID] = similarUsersbyFollows[user][followUserID] * matrixUserItem[followUserID][itemID]

    contributingUsers = list((-contributions).argsort())
    filteredContributingUserIds = contributingUsers[0:k]
    filteredContributingUsers = list()

    for filteredContributingUserId in filteredContributingUserIds:
      filteredContributingUsers.append('User-{}'.format(filteredContributingUserId))

    explainableUsers[itemID] = filteredContributingUsers

  return explainableUsers

"""#### Explainable Testing"""

getExplainableforUserbyRating(0, [2269, 633, 192], 2)

getExplainableforUserbyFollows(0, [1680, 179], 1)

"""## User User CF"""

def getUserRecommendation(user, k, similarUsers):
  ratings = matrixUserItem[user]
  similarUserKeys = list(similarUsers[user].keys())
  filteredRatings = np.where(ratings == 0)[0]

  unknownSimilarity = dict()
  for filteredRating in filteredRatings:
    numerator = 0
    denominator = 0

    for key in similarUserKeys:
      numerator += similarUsers[user][key] * matrixUserItem[key][filteredRating]
      denominator += similarUsers[user][key]

    if denominator == 0:
      continue

    unknownSimilarity[filteredRating] = numerator / denominator

  sortedUnknownSimilarity = dict(sorted(unknownSimilarity.items(), key=lambda item: item[1], reverse=True))
  userSimilarityRecommendation = list(sortedUnknownSimilarity.keys())[0:k]

  return userSimilarityRecommendation

"""#### User-User Testing"""

# Testing by ratings similarity
getUserRecommendation(0, 3, similarUsersbyRating)

# Testing by follows similarity
getUserRecommendation(0, 5, similarUsersbyFollows)

"""## User Item Recommendation"""

def get_user_item_recommendation(user_id, item_id, k, similarUsers, similarItems):
  potential_items = dict()
  candidateItems = similarItems[item_id]
  for j, j_sim in candidateItems.items():
    num = 0
    den = 0
    for v, v_sim in similarUsers[user_id].items():
      num += v_sim * matrixUserItem[v][j]
      den += v_sim

    if den == 0:
      continue

    potential_items[j] = num/den * j_sim
    # potential_items[j] = (2 * num/den * j_sim)/(num/den + j_sim)

  potential_items = {k: v for k, v in sorted(potential_items.items(), key=lambda item: item[1], reverse=True)[:k]}
  return list(potential_items.keys())

"""#### User-Item Testing"""

# Testing by ratings similarity
get_user_item_recommendation(0, 1680, 3, similarUsersbyRating, similarItemsbyTag)

# Testing by follows similarity
get_user_item_recommendation(0, 1680, 5, similarUsersbyFollows, similarItemsbyTag)

"""## Recommendation API"""

def recommendationsforUser(userId):
  ratingsRecommendation = getUserRecommendation(userId, 3, similarUsersbyRating)
  followsRecommendation = getUserRecommendation(userId, 5, similarUsersbyFollows)

  ratingsExplainable = getExplainableforUserbyRating(userId, ratingsRecommendation, 2)
  followsExplainable = getExplainableforUserbyFollows(userId, followsRecommendation, 1)

  recommendations = list()
  recommendationIds = list()
  for i in ratingsRecommendation:
    recipeName = itemNamesDF[itemNamesDF['recipe_id'] == i]['name'].item()
    recommendation = dict()
    recommendation['id'] = int(i)
    recommendation['type'] = 'Rating'
    recommendation['name'] = recipeName
    recommendation['tags'] = ratingsExplainable[i]
    recommendations.append(recommendation)
    recommendationIds.append(i)

  for i in followsRecommendation:
    if len(recommendations) >= 5:
      break

    if i in recommendationIds:
      continue

    recipeName = itemNamesDF[itemNamesDF['recipe_id'] == i]['name'].item()
    recommendation = dict()
    recommendation['id'] = int(i)
    recommendation['type'] = 'Follows'
    recommendation['name'] = recipeName
    recommendation['tags'] = followsExplainable[i]
    recommendations.append(recommendation)
    recommendationIds.append(i)

  return recommendations

def recommendationsforUserItem(userId, itemId):
  ratingsRecommendation = get_user_item_recommendation(userId, itemId, 3, similarUsersbyRating, similarItemsbyTag)
  followsRecommendation = get_user_item_recommendation(userId, itemId, 5, similarUsersbyFollows, similarItemsbyTag)

  ratingsExplainable = getExplainableforUserbyRating(userId, ratingsRecommendation, 2)
  followsExplainable = getExplainableforUserbyFollows(userId, followsRecommendation, 1)

  recommendations = list()
  recommendationIds = list()
  for i in ratingsRecommendation:
    recipeName = itemNamesDF[itemNamesDF['recipe_id'] == i]['name'].item()
    recommendation = dict()
    recommendation['id'] = int(i)
    recommendation['type'] = 'Rating'
    recommendation['name'] = recipeName
    recommendation['tags'] = ratingsExplainable[i]
    recommendations.append(recommendation)
    recommendationIds.append(i)

  for i in followsRecommendation:
    if len(recommendations) >= 5:
      break

    if i in recommendationIds:
      continue

    recipeName = itemNamesDF[itemNamesDF['recipe_id'] == i]['name'].item()
    recommendation = dict()
    recommendation['id'] = int(i)
    recommendation['type'] = 'Follows'
    recommendation['name'] = recipeName
    recommendation['tags'] = followsExplainable[i]
    recommendations.append(recommendation)
    recommendationIds.append(i)

  return recommendations

"""#### Recommendation API Testing"""

recommendationsforUser(1)

recommendationsforUserItem(1, 1095)

"""## Users API"""

def get_unique_users():
  users = list()
  for i in range(matrixUserItem.shape[0]):
    user = dict()

    user['id'] = i
    user['name'] = 'User-{}'.format(i)

    users.append(user)

  return users

def getUser(userId):
  user = dict()
  followUsers = np.where(matrixUserFollows[userId] > 0)[0]

  user['id'] = userId
  user['name'] = 'User-{}'.format(userId)
  user['follows'] = list()

  for followUser in followUsers:
    follow = dict()
    follow['id'] = int(followUser)
    follow['name'] = 'User-{}'.format(followUser)
    user['follows'].append(follow)

  return user

def editUserFollows(userId, followUserIds):
  matrixUserFollows[userId] *= 0

  for followUserId in followUserIds:
    matrixUserFollows[userId][followUserId] = 1

  updateUserFollowsSimilarity(userId)

"""## Recipe API"""

def getRecipe(itemId):
  recipe = dict()
  recipeDF = itemNamesDF[itemNamesDF['recipe_id'] == itemId]

  recipe['id'] = itemId
  recipe['name'] = recipeDF['name'].item()
  recipe['tags'] = recipeDF['tags'].item()
  recipe['description'] = recipeDF['description'].item()
  recipe['ingredients'] = recipeDF['ingredients'].item()
  recipe['minutes'] = recipeDF['minutes'].item()
  recipe['steps'] = recipeDF['steps'].item()

  return recipe

def getAllRecipes():
  recipes = list()

  for itemId in range(len(filteredItems)):
    recipe = dict()
    recipeDF = itemNamesDF[itemNamesDF['recipe_id'] == itemId]

    recipe['id'] = itemId
    recipe['name'] = recipeDF['name'].item()
    tags = ast.literal_eval(recipeDF['tags'].item())
    tags = [tag for tag in tags if tag not in badTags]
    recipe['tags'] = tags
    recipe['nutrition'] = recipeDF['nutrition'].item()

    recipes.append(recipe)

  return recipes

def getAllTags():
  uniqueTags = set()
  for index, row in itemNamesDF.iterrows():
    tags = ast.literal_eval(row['tags'])
    uniqueTags.update(tags)
  return uniqueTags

uniqueUsers = get_unique_users()
allRecipes = getAllRecipes()
allTags = getAllTags()


@app.route('/user', methods=['GET'])
@cross_origin()
def getUserDetails():
  args = request.args
  userId = int(args.get('userId'))
  return jsonify(getUser(userId))

@app.route('/user', methods=['POST'])
@cross_origin()
def getUserDetail():
  args = request.args
  userId = int(args.get('userId'))
  followers = list(request.json)
  editUserFollows(userId,followers)
  return jsonify({"message": f"User-{userId} followers successfully updated"})

@app.route('/users', methods=['GET'])
@cross_origin()
def userList():
  return jsonify(uniqueUsers)

@app.route('/recipes', methods=['GET'])
@cross_origin()
def recipes():
  return jsonify(allRecipes)

@app.route('/recipe', methods=['GET'])
@cross_origin()
def recipesRec():
  args = request.args
  recipeId = int(args.get('recipeId'))

  if any(d['id'] == recipeId for d in allRecipes):
    return jsonify(getRecipe(recipeId))
  else:
    return jsonify({"error": "Recipe Id Not found"})

@app.route('/recommendation', methods=['GET'])
@cross_origin()
def recommendation():
  args = request.args
  userId = int(args.get('userId'))
  if any(d['id'] == userId for d in uniqueUsers):
    return jsonify(recommendationsforUser(userId))
  else:
    return jsonify({"error": "User Not found"})

@app.route('/recommendationBasedOnClick', methods=['GET'])
@cross_origin()
def recommendationBasedOnClick():
  args = request.args
  userId = int(args.get('userId'))
  recipeId = int(args.get('recipeId'))
  if any(d['id'] == userId for d in uniqueUsers):
    return jsonify(recommendationsforUserItem(userId, recipeId))
  else:
    return jsonify({"error": "User Not found"})


if __name__ == '__main__':
	app.run()
